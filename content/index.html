---
title: Linux firewalling and traffic shaping for humans
submenu: home
---

<% entry = news_items.shift %>
<div class="latest_news">
  <h4>Latest News</h4>
  <p><%= news_date(entry) %> -
        <span class="news_title"><%= news_title(entry) %></span>
      <a href="/news/">[more ...]</a>
  </p>
</div>

<h2>What are FireHOL and FireQOS?</h2>

<p>FireHOL is a language (and a program to run it) which builds secure,
   stateful firewalls of any complexity from easy to understand,
   human-readable configurations.
</p>

<p>FireQOS is a program which sets up traffic shaping from an
   easy-to-understand and flexible configuration file.
</p>

<p>We think the best advert for these programs are their configurations.
See below for:
</p>

<ul>
  <li><a href="/#firehol">a FireHOL example and more information</a></li>
  <li><a href="/#fireqos">a FireQOS example and more information</a></li>
</ul>

<p>The two programs are shipped together but work independently so you
   can choose to use one or both.</p>

<h2>Philosophy</h2>

<ul>
  <li>Make firewalling and traffic shaping an easy, straightforward task
      for everyone from end users to experienced administrators.
  </li>

  <li>Be as secure as possible by allowing explicitly only the wanted
      traffic to flow.
  </li>

  <li>Be a resource of knowledge around services and their peculiarities.
  </li>

  <li>Be flexible enough for any firewalling or traffic-shaping need.
  </li>

  <li>Be simple to install on any modern Linux system
  </li>
</ul>

<h2 id="firehol">FireHOL</h2>

<p>FireHOL is an iptables firewall generator producing stateful
iptables packet filtering firewalls, on Linux hosts and routers
with any number of network interfaces, any number of routes, any
number of services served, any number of complexity between
variations of the services (including positive and negative
expressions).</p>

<p>Writing a firewall can be this easy:</p>

<%= fhmanual_example('overview-01') %>

<p>Jump straight to the <a href="/tutorial/">tutorials</a> to learn how
to configure your own.</p>

<p>Hopefully you have noticed that all the rules given match just one
direction of the traffic: <span class="important">the request</span>.
They don't say anything about replies. This is because FireHOL handles
the replies automatically. You don't have to do anything about them: if
a request is allowed, then the corresponding reply is also allowed.
This also means that FireHOL produces the iptables statements to exactly
match what is allowed <span class="important">in both directions</span>
and nothing more.<p>

<p>
FireHOL is a <span class="important">language to express firewalling
rules</span>, not just a script that produces some kind of a firewall.
</p>

<h3>Is it secure?</h3>

<p>
FireHOL is <span class="important">secure</span> because it has been
designed with the right firewalling concept:
<span class="important">deny everything, then allow only what is needed</span>.
</p>

<p>
Also, FireHOL produces <span class="important">stateful</span> iptables
packet filtering firewalls (and possibly, the only generic tool today that
does that for all services in both directions of the firewall).
</p>

<p>
Stateful means that traffic allowed to pass is part of a valid
connection that has been initiated the right way. Stateful also
means that you can have control based on who initiated the traffic.
For example: you can choose to be able to ping anyone on the internet,
but no one to be able to ping you. If for example you don't need to
run a server on your Linux host, you can easily achieve a situation where
you are able to do anything to anyone, but as far as the rest of world
is concerned, <span class="important">you do not exist</span>!
</p>

<h3>Learn another language?</h3>

<p>FireHOL has been designed to allow you configure your firewall the
same way you think of it. Its language is extremely simple.
Basically you have to learn four commands:</p>

<ul>
  <li><%= fh_manref('def-interface','interface') %>, to setup a
      firewall on a network interface
  </li>

  <li><%= fh_manref('def-router','router') %>, to setup a 
      firewall on traffic routed from one network interface to another
  </li>

  <li><%= fh_manref('cmd-server','server') %>, to setup a
      listening service within an interface or router.
      The same command can be used as
      <%= fh_manref('cmd-server','route') %> within routers
  </li>

  <li><%= fh_manref('cmd-client','client') %>, to setup a service
      client within an interface or router
  </li>
</ul>

<p>
Commands <%= fh_manref('cmd-client','client') %> and
<%= fh_manref('cmd-server','server') %> have exactly the same syntax.
A FireHOL <%= fh_manref('def-interface','interface') %> has two mandatory
arguments and a <%= fh_manref('def-router','router') %> has only one
(and this is the same with one of the two
<%= fh_manref('def-interface','interface') %> requires).
All the <%= fh_manref('rule-params','optional&nbsp;parameters') %> are the
same to all of them. This sounds like just one command is to be learned...
</p>

<p>
Of course there are a
<%= fh_manref('firehol.conf-commands','few&nbsp;more&nbsp;commands') %>
defined, but all of them exist just to give you finer control on these four.
</p>

<p>If you don't believe it is simple, consider
<a href="/tutorial/#fw-by-goal">this example</a>.</p>

<h3>Why?</h3>

<p>As an IT executive, responsible for many dozens of Linux systems,
I needed a firewalling solution that would allow me and my team to
have a clear and simple view of what is happening on each server,
as far as firewalling is concerned. I also needed a solution that
will allow my team members to produce high quality and homogeneous
firewalls independently of their security skills and knowledge.
After searching for such a tool, I quickly concluded that no tool is
flexible, open, easy, and simple enough for what I needed.</p>

<p>I decided to write FireHOL in a way that will allow me, or anyone else,
to view, verify and audit the firewall of any Linux server or Linux router
<span class="important">in seconds</span>. FireHOL's configuration is
extremely simple... you don't have to be an expert to design a complicated
but secure firewall.</p>

<h3>What features does it have?</h3>

<p>FireHOL handles firewalls protecting one host on all its interfaces
and any combination of stateful firewalls routing traffic from one
interface to another. There are no limitations on the number of
interfaces or on the number of routing routes (except the ones
iptables has, if any).</p>

<p>FireHOL, still lacks a few features: QoS for example is not supported
directly. You are welcome to extend FireHOL and send me your patches
to integrate within FireHOL. In any case however, you can embed normal
iptables commands in a FireHOL configuration to do whatever
iptables supports.</p>

<p>Since FireHOL produces stateful commands, for every supported
service it needs to know the flow of requests and replies. Today
FireHOL supports the following services:</p>

<ul>
  <li>Many single socket protocols, such as HTTP, NNTP, SMTP, POP3, 
      IMAP4, RADIUS, SSH, LDAP, MySQL, Telnet, NTP, DNS, etc.
      There are a few dozens of such services defined in FireHOL.
      Check <a href="/services/">this list</a>. Even if something is
      missing, you can <%= fh_manref('adding-services','define&nbsp;it') %>.
  </li>

  <li>Many complex protocols, such as FTP, NFS, SAMBA, PPTP, etc. 
      If you need some complex protocol that is not present, you will have 
      to program it (in simple BASH scripting - there are many commented 
      examples on how this is done). Again, you will just create one BASH 
      function with the rules of the protocol, and FireHOL will turn it to
      a client, a server or a router.
  </li>
</ul>

<h2 id="fireqos">FireQOS</h2>

<p>
    FireQOS is a traffic shaping helper. It has a very
    simple shell scripting language to express traffic shaping.
    You run FireQOS to setup the kernel commands. You can also
    run it to get status information or dump the traffic of a
    class. FireQOS is not a daemon and does not need to run
    always to apply traffic shaping.
</p>

<p>Configuring traffic shaping can be this easy:</p>

<%= fhmanual_example('overview-qos-01') %>

<p>Jump straight to the <a href="/tutorial/">tutorials</a> to learn how
to configure your own.</p>

<p>FireQOS also allows you to monitor the live status of traffic:</p>

<pre class="programoutput">
# ./sbin/fireqos.in status adsl-in
FireQOS v1.0 DEVELOPMENT
(C) 2013 Costa Tsaousis, GPL


adsl-in: eth0 input =&gt; ifb0, type: adsl, overhead: 26
Rate: 10500Kbit/s, min: 105Kbit/s, R2Q: 8 (min rate 105Kbit/s)
Values in Kbit/s

  CLASS    voip realtim clients torrent default
PRIORIT       1       2       3       5       4
 COMMIT     105    1050    1050     105     105
    MAX   10500   10500   10500    9450    9450


   adsl-in (eth0 input =&gt; ifb0) - values in Kbit/s
  TOTAL    voip realtim clients torrent default
     46       -       7       -      39       -
     50       -       5       -      42       3
     80       -       9       -      60      11
     75       -       6       -      65       4
    103      19       3       -      79       2
     56       -       3       -      50       3
     84       -       5       -      70       9
</pre>

<ul>
  <li>
    FireQOS applies traffic shaping on the output of any
    interface.
  </li>

  <li>
    FireQOS applies traffic shaping on the input of any
    interface. Shaping incoming traffic is classfull, i.e. you
    have all the control available, similar to outgoing
    traffic. This is accomplished by setting up IFB devices.
    FireQOS handles everything about IFB devices. Any kernel
    that supports them will do.
  </li>

  <li>
    FireQOS supports overheads calculation. This means it
    can perfectly shape incoming and outgoing traffic on a
    linux box behind an ADSL router, or on a linux box with an
    ADSL modem attached. ATM overheads will be calculated based
    on the DSL encapsulation.
  </li>

  <li>
    FireQOS supports both IPv4 and IPv6. Each interface can
    be defined as ipv4, ipv6 or both (ipv4 and ipv6 in
    parallel).
  </li>

  <li>
    FireQOS supports nested classes. Nested classes can
    either be direct (child classes are directly attached to
    their parent class), or hardware emulation (child classes
    are attached to a qdisc with linklayer parameters and
    overheads calculation, which is attached to a parent class).
  </li>

  <li>
    FireQOS calculates port range masks (you just give a
    port range, FireQOS finds the optimal combination of tc
    statements to accomplish the match).
  </li>

  <li>
    Virtually any number of interfaces, any number of
    classes and any number of classification rules can be
    configured (the way it is organized it can configure up to
    5000 classes per interface).
  </li>

  <li>
    It classifies packets using tc (both ipv4 and ipv6),
    but you can also use iptables CLASSIFY targets, or MARKs.
  </li>

  <li>
    <a href="http://luxik.cdi.cz/%7Edevik/qos/htb/manual/userg.htm" >HTB</a>
    is used for all classes.
  </li>

  <li>
    FireQOS allows you to tcpdump the traffic of any leaf
    class. This allows you to examine the traffic you have
    assigned to classes.
  </li>
</ul>
